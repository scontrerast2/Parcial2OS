#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define INTERVALO_SEG     2          // segundos entre lecturas
#define BUFFER_SIZE       1024

// Estructura para guardar los valores de /proc/stat (cpu total)
typedef struct {
    unsigned long long user;
    unsigned long long nice;
    unsigned long long system;
    unsigned long long idle;
    unsigned long long iowait;
    unsigned long long irq;
    unsigned long long softirq;
    unsigned long long steal;
    unsigned long long guest;
    unsigned long long guest_nice;
} CpuStats;

// Lee la línea "cpu " (total de todos los cores) de /proc/stat
int leer_cpu_stats(CpuStats *stats) {
    FILE *fp = fopen("/proc/stat", "r");
    if (!fp) return -1;

    char linea[256];
    if (fgets(linea, sizeof(linea), fp)) {
        if (strncmp(linea, "cpu ", 4) == 0) {
            sscanf(linea, "cpu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu",
                   &stats->user, &stats->nice, &stats->system, &stats->idle,
                   &stats->iowait, &stats->irq, &stats->softirq,
                   &stats->steal, &stats->guest, &stats->guest_nice);
            fclose(fp);
            return 0;
        }
    }
    fclose(fp);
    return -1;
}

// Calcula los deltas y los porcentajes
void calcular_porcentajes(const CpuStats *prev, const CpuStats *curr,
                          double *total_usage, double *user_pct,
                          double *system_pct, double *idle_pct) {
    unsigned long long prev_idle = prev->idle + prev->iowait;
    unsigned long long curr_idle = curr->idle + curr->iowait;

    unsigned long long prev_non_idle = prev->user + prev->nice + prev->system +
                                       prev->irq + prev->softirq + prev->steal;
    unsigned long long curr_non_idle = curr->user + curr->nice + curr->system +
                                       curr->irq + curr->softirq + curr->steal;

    unsigned long long prev_total = prev_idle + prev_non_idle;
    unsigned long long curr_total = curr_idle + curr_non_idle;

    unsigned long long total_diff = curr_total - prev_total;
    unsigned long long idle_diff  = curr_idle - prev_idle;

    if (total_diff == 0) {
        *total_usage = 0.0;
        *user_pct = *system_pct = *idle_pct = 0.0;
        return;
    }

    *total_usage = 100.0 * (total_diff - idle_diff) / total_diff;
    *idle_pct    = 100.0 * idle_diff / total_diff;

    unsigned long long user_diff = curr->user - prev->user + curr->nice - prev->nice;
    unsigned long long system_diff = curr->system - prev->system;

    *user_pct    = 100.0 * user_diff / total_diff;
    *system_pct  = 100.0 * system_diff / total_diff;
}

const char* obtener_ip_agente(const char *ip_provisto) {
    return (ip_provisto && strlen(ip_provisto) > 0) ? ip_provisto : "127.0.0.1";
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Uso: %s <ip_recolector> <puerto> [ip_logica_agente]\n", argv[0]);
        fprintf(stderr, "Ejemplo: %s 192.168.1.100 5000 192.168.1.50\n", argv[0]);
        return 1;
    }

    const char *ip_recolector = argv[1];
    int puerto = atoi(argv[2]);
    const char *ip_agente = (argc >= 4) ? argv[3] : "";
    ip_agente = obtener_ip_agente(ip_agente);

    // Crear y conectar socket TCP
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("socket");
        return 1;
    }

    struct sockaddr_in servidor;
    servidor.sin_family = AF_INET;
    servidor.sin_port = htons(puerto);
    if (inet_pton(AF_INET, ip_recolector, &servidor.sin_addr) <= 0) {
        perror("inet_pton");
        return 1;
    }

    if (connect(sock, (struct sockaddr*)&servidor, sizeof(servidor)) < 0) {
        perror("connect");
        return 1;
    }

    printf("Conectado al recolector %s:%d como agente %s\n", ip_recolector, puerto, ip_agente);
    printf("Enviando datos de CPU cada %d segundos...\n", INTERVALO_SEG);

    CpuStats prev, curr;
    if (leer_cpu_stats(&prev) < 0) {
        fprintf(stderr, "Error leyendo /proc/stat\n");
        return 1;
    }

    // Primera espera para tener un delta válido
    sleep(INTERVALO_SEG);

    while (1) {
        if (leer_cpu_stats(&curr) < 0) {
            fprintf(stderr, "Error leyendo /proc/stat\n");
            break;
        }

        double total_usage, user_pct, system_pct, idle_pct;
        calcular_porcentajes(&prev, &curr, &total_usage, ¬e_pct, &system_pct, &idle_pct);

        // Construir mensaje
        char mensaje[BUFFER_SIZE];
        snprintf(mensaje, sizeof(mensaje),
                 "CPU;%s;%.2f;%.2f;%.2f;%.2f\n",
                 ip_agente, total_usage, user_pct, system_pct, idle_pct);

        // Enviar
        if (send(sock, mensaje, strlen(mensaje), 0) < 0) {
            perror("send");
            break;
        }

        printf("[%ld] Enviado: %s", time(NULL), mensaje);

        prev = curr;  // preparar para la siguiente iteración
        sleep(INTERVALO_SEG);
    }

    close(sock);
    return 0;
}
